options(stringsAsFactors = FALSE)
library(ggbeeswarm)
library(tidyverse)
library(genetics)
library(mvtnorm)
library(BiocParallel)
library(qtl2)

# Simulate phenotypes at specific SNPs.
# probs: qtl2-style genoprobs object from calc_genoprob().
# Kcor: genoprobs correlation matrix (not qtl2-style kinship. mean cosine of angle between each sample.)
# map: qtl2-style marker map.
# effects: data.frame containing 2 rows and 3 columns. 
#          chr: character vector, chromosome name. Prefer one chr for now.
#          pos: numeric vector, Mb positions.
#          split: numeric vector with 1, 2, 3 or 4, indicating the number of founders to get effect. 
# hsq: numeric value between 0 & 1 indicating the heritability of the phenotype at the QTL.
#
# NOTE: I tried to specify the specific founder allele pattern and found that the requested
# pattern may not be found at a given locus. We also can't specify the overlap yet.
#
# query_func: variant query function.
# Returns: list with two elements:
#          pheno: Matrix with one column containing phenotype. H_sq in attr().
#          sim_geno: data.frame containing exact location and SDP of simulated SNPs.
simulate_phenotype = function(probs, Kcor, map, effects, hsq, query_func) {

  n_samples = nrow(probs[[1]])
  
  # Simulate polygenic noise.
  pheno = mvtnorm::rmvnorm(n = n_samples, mean = rep(0, nrow(Kcor)), sigma = Kcor)[1,]
  pheno_mean = mean(pheno)
  pheno_sd   = sd(pheno)
  
  gen_effect = rep(0, length(pheno))
  sim_geno = NULL
  
  # If the lowest position is before the first marker, then move it over.
  if(min(effects$pos) <= min(map[[effects$chr[1]]])) {
    
    offset = min(map[[effects$chr[1]]]) - min(effects$pos)
    effects$pos = effects$pos + offset
    
  } # if(min(effects$pos) <= min(map[[effects$chr[1]]]))
  
  # Simulate the effects at each locus.
  for(row in 1:nrow(effects)) {
  
    curr_chr = effects$chr[row]
    curr_pos = effects$pos[row]
    curr_eff = effects$split[row]
  
    gt = get_genotype(probs, query_func, curr_chr, curr_pos, curr_eff)
  
    # If we couldn't find genotypes with the requests allele frequency,
    # then return NULL.
    if(is.null(gt)) {
      return(NULL)
    } # if(is.null(gt))
  
    # Add locus effect.
    # Add 1 * pheno_sd per allele; so 2 * pheno_sd for homozygotes.
    gen_effect = gen_effect + 2 * gt$pr * pheno_sd
    if(is.null(sim_geno)) {
      sim_geno = gt$sim_geno
    } else{
      sim_geno   = rbind(sim_geno, gt$sim_geno)
    } # else

  } # for(row)
  
  # Add genetic effects to phenotype and return.
  pheno = as.matrix((1 - hsq) * pheno + hsq * gen_effect)
  
  attr(pheno, 'hsq') = var(hsq * gen_effect) / var(pheno[,1])

  return(list(pheno = pheno, sim_geno = sim_geno))
    
} # simulate_phenotype()


# Returns: list with two elements:
#          probs: qtl2-style genoprobs.
#          query_func: SNP query function generated by qtl2::create_variant_query_func().
#          chr: character, chromosome name.
#          pos: numeric, Mb position (we'll search +/- 1 Mb)
#          eff: numeric (1 - 4), number of founders to get effect.
# Note that we use the 'B' allele in qtl2's SNP probs.
get_genotype = function(probs, query_func, chr, pos, eff) {
  
  founder_names = c('A_J',       'C57BL_6J', '129S1_SvImJ', 'NOD_ShiLtJ', 
                    'NZO_HlLtJ', 'CAST_EiJ', 'PWK_PhJ',     'WSB_EiJ')
  
  # Get the SNPs from Karl's SNP DB.
  snps = query_func(chr, pos - 1, pos + 1)
  # Retain only SNPs. (TBD: Include indels & SVs?)
  snps = subset(snps, type == 'snp')
  # For now, remove SNPs with three alleles. (TBD: Include these.)
  snps = snps[rowSums(snps[,founder_names] == 3) == 0,]
  # Retain only the columns we need.
  snps = snps[,c('snp_id', 'chr', 'pos', 'alleles', 'sdp', founder_names)]
  # Get the strain distribution patterns (SDPs) as numbers (0 or 1).
  sdps = as.matrix(snps[,founder_names]) - 1
  rownames(sdps) = snps$snp_id
  # Find the SDPs that match the desired pattern.
  sdps = sdps[rowSums(sdps) == eff,,drop = FALSE]
  
  # If we couldn't find the SDP, tell the user and show the available SDPs
  # in this 2 Mb interval.
  if(nrow(sdps) == 0) {
    print(paste("Can't find SNPs with SDP containing", eff, "founders."))
    return(NULL)
  } # if(length(cand_snps) == 0)
  
  # Select the SNP closest to the requested position.
  snps = snps[match(rownames(sdps), snps$snp_id),]
  snps = snps[which.min(abs(pos - snps$pos)),]
  
  # Get the SNP probs for the DO samples at this only SNP.
  snpinfo = index_snps(map, snpinfo = snps)
  pr = genoprob_to_snpprob(probs, snpinfo)[[1]][,'B',1]
  
  # Change SNP alleles from 1/2 to 0/1.
  snps[,founder_names] = snps[,founder_names] - 1
  
  return(list(pr = pr, sim_geno = snps))

} # get_genotype()


# Get the mean cosine angle between each pair of samples.
# This is not kinship, but correlation for the mvnorm functions.
sample_correlation = function(probs) {
  
  n_samples = sapply(probs, dim)[1,1]
  n_markers = sapply(probs, dim)[3,]
  
  retval = matrix(0, n_samples, n_samples, 
                  dimnames = list(rownames(probs), rownames(probs)))
  
  for(i in seq_along(probs)) {
    
    print(paste('Chr', names(probs)[i]))
    
    for(j in 1:n_samples) {
      mag_a = sqrt(colSums(probs[[i]][j,,]^2))
      for(k in j:n_samples) {
        mag_b       = sqrt(colSums(probs[[i]][k,,]^2))
        dot_prod    = colSums(probs[[i]][j,,] * probs[[i]][k,,])
        retval[j,k] = retval[j,k] + sum(dot_prod / (mag_a * mag_b))
        retval[k,j] = retval[j,k]
      } # for(k)
    } # for(j)
  } # for(i)
  
  # Divide by number of markers to get correlation.
  return(retval / sum(n_markers))
  
} # sample_correlation()


# Parallel version.
# NOT TESTED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
sample_correlation_par = function(probs, cores, out_dir) {
  
  bpparam = MulticoreParam(workers = cores, progressbar = TRUE, log = TRUE, logdir = out_dir)

  FXN = function(i) {
    pr = probs[[i]]
    n_samples = dim(pr)[1]
    n_markers = dim(pr)[3]
    retval = matrix(0, n_samples, n_samples, 
                    dimnames = list(rownames(probs), rownames(probs)))
    
    mag = sqrt(apply(pr^2, 1, colSums))

    dp = matrix(0, n_samples, n_markers)
    for(i in 1:n_samples) {
      tmp = sweep(pr, 2:3, pr[i,,], '*')
      for(j in 1:n_markers) {
        dp[,j] = rowSums(tmp[,,j])
      } # for(j)
      retval[i,] = rowSums(dp / t(mag[,i] * mag))
    } # for(i)

    return(retval)
    
  } # FXN()

  result = bplapply(X = 1:length(probs), FUN = FXN, BPPARAM = bpparam)
  
  # Add results from each chromosome & divide by num_markers.
  n_markers = sum(sapply(probs, dim)[3,])
  retval = result[[1]]
  for(i in 2:length(result)) {
    retval = retval + result[[i]]
  } # for(i)
  
  return(retval / n_markers)
  
} # sample_correlation_par()


# Given the simulated and found peaks, indicate whether 0, 1 or 2 peaks were found.
# Arguments:
# sim_peaks: data.frame containing simulated peak info. 2 rows per peak.
# found_peaks: data.frame containing peaks found, with confidence interval.
compare_peaks = function(sim_peaks, found_peaks) {
  
  sim_peaks = sim_peaks %>% 
                 dplyr::select(sim, hsq, chr, pos)
  
  # Check if we have one or two peaks per simulation.
  num_sim_peaks = sim_peaks %>% 
                    count(sim) %>% 
                    distinct(n) %>% 
                    pull(n)
  
  if(num_sim_peaks > 1) {
    sp1 = sim_peaks %>% 
            slice(seq(1, nrow(sim_peaks), 2))
    sp2 = sim_peaks %>% 
            slice(seq(2, nrow(sim_peaks), 2)) %>% 
            dplyr::select(-hsq)
    sim_peaks = full_join(sp1, sp2, by = c('sim', 'chr')) %>% 
                  dplyr::rename(pos1 = pos.x,
                                pos2 = pos.y)
    rm(sp1, sp2)
  } # if(num_sim_peaks > 1)
  
  found_peaks = found_peaks %>% 
                  dplyr::select(sim, chr:ci_hi)
  
  retval = NULL
  if(num_sim_peaks > 1) {
    retval = full_join(sim_peaks, found_peaks, by = c('sim', 'chr')) %>% 
             mutate(num_found = if_else(pos1 >= ci_lo & pos1 <= ci_hi, 1,             0),
                    num_found = if_else(pos2 >= ci_lo & pos2 <= ci_hi, num_found + 1, num_found))
  } else {
    found_peaks = dplyr::select(found_peaks, -pos)
    retval = full_join(sim_peaks, found_peaks, by = c('sim', 'chr')) %>% 
               mutate(num_found = if_else(pos >= ci_lo & pos <= ci_hi, 1, 0),)
  } # else
  
  return(retval)
  
} # compare_peaks()


# Given the simulated SNPs and the maximum assoc SNPs, determine whether the
# simulated SNPs are in the set of top SNPs.
# Arguments:
# sim_loci: data.frame containing the simulated loci, with SNP IDs.
# sim_num: the simulation number to compare with top_snps.
# top_snps: data.frame containing SNPs in the top set from association mapping.
# Returns: data.frame containing all simulated SNPs. If the simulated SNP
#          was detected, include the LOD and LOD rank. If not, include NA.
compare_top_snps = function(sim_loci, sim_num, top_snps) {

  # Subset sim_loci to keep the requested simulation.
  sim_loci = subset(sim_loci, sim == sim_num)
  
  top_snps = top_snps %>% 
               dplyr::select(snp_id, lod) %>% 
               arrange(desc(lod)) %>% 
               mutate(lod_rank   = dense_rank(-lod))
  
  return(left_join(sim_loci, top_snps, by = 'snp_id'))

} # compare_top_snps()


# Add the genotype at a given marker and remap phenotype.
rescan1 = function(probs, pheno, K, addcovar, map, chr, pos, sim_loci, query_func) {
  
  # Get the genotypes at the requested marker.
  snps = query_func(chr, pos, pos)
  snps = index_snps(map, snps)
  # This only gives us the unique SDPs, not ALL SNPs.
  gt = genoprob_to_snpprob(probs, snps)[[1]][,'B',]
  
  addcovar = cbind(addcovar, gt)
  start = min(sim_loci$pos) - 1
  end   = max(sim_loci$pos) + 1
  
  assoc = scan1snps(genoprobs = probs[,chr],
                    map       = map,
                    pheno     = pheno,
                    kinship   = K[[chr]],
                    addcovar  = addcovar,
                    chr       = chr,
                    start     = start,
                    end       = end,
                    query_func = snp_func,
                    keep_all_snps = TRUE,
                    cores     = 4)

  sim_num = sim_loci$sim[1]
  
  png(file.path(sim_out_dir, 'assoc_regr_plots', paste0('sim', sim_num, '_assoc_regr.png')),
      width = 1000, height = 800, res = 128)
  plot_snpasso(assoc$lod, assoc$snpinfo, show_all_snps = TRUE, col = 'black', 
               main = paste('Sim', sim_num, paste(sim_loci$pos, collapse = ' & '), '\n', snps$snp_id, 'regressed out'))
  abline(v = sim_loci$pos, col = 'red', lty = 3, lwd = 2)
  points(x = snps$pos[1], y = 0, pch = 17, col = 'orange', cex = 3)
  dev.off()
  
  # Save association mapping data.
  saveRDS(assoc, file = file.path(sim_out_dir, 'assoc_regr_plots', paste0('sim', sim_num, '_assoc_regr.rds')))
  
  # Get the top 0.5% of SNPs.
  max_lod = maxlod(assoc$lod)
  thr     = quantile(assoc$lod, probs = 0.995)
  # Careful here: the gene column contains comma's, so use TAB delimiter.
  write.table(top_snps(assoc$lod, assoc$snpinfo, drop = max_lod - thr), 
              file = file.path(sim_out_dir, 'assoc_regr_plots', paste0('sim', sim_num, '_top_snps.txt')),
              quote = FALSE, sep = '\t')
  
    
} # rescan1()


##########
# Given two SNPs, plot the phenotype X genotype interaction, without kinship.
# Note that we use the 'B' allele in qtl2's SNP probs.
# pos: data.frame form sim_loci containing chr, and Mb position of simulated SNPs.
# TBD: Add kinship.
plot_pxg_snps = function(genoprobs, pheno, addcovar, map, pos, query_func) {
  
  # Regress out additive covariates from phenotype.
  mean_pheno = mean(pheno[,1], na.rm = TRUE)
  mod = lm(pheno[,1] ~ addcovar)
  res = residuals(mod)
  new_pheno = data.frame(id = rownames(pheno), pheno = mean_pheno + res)
  
  # Get SNP genptypes.
  chr1 = pos$chr[1]
  chr2 = pos$chr[2]
  pos1 =pos$pos[1]
  pos2 =pos$pos[2]
  
  si1 = query_func(chr1, pos1, pos1)
  si1 = qtl2:::index_snps(map, si1)
  gt1 = genoprob_to_snpprob(genoprobs, si1)[[1]][,'B',1]
  
  si2 = query_func(chr2, pos2, pos2)
  si2 = qtl2:::index_snps(map, si2)
  gt2 = genoprob_to_snpprob(genoprobs, si2)[[1]][,'B',1]
  
  gt1 = data.frame(id = names(gt1), gt1 = round(2 * gt1))
  gt2 = data.frame(id = names(gt2), gt2 = round(2 * gt2))
  
  return(full_join(gt1, gt2, by = 'id') %>% 
    full_join(new_pheno, by = 'id') %>% 
    mutate(gt2 = as.character(gt2)) %>% 
    ggplot(aes(gt1, pheno, color = gt2)) +
      geom_beeswarm() +
      geom_smooth(aes(group = gt2), method = 'lm') +
      scale_color_brewer(palette = 'Dark2') +
      labs(title = str_c('Chr', chr1, ': GT1 =', pos1, ': GT2 =', pos2, sep = ' '),
           x = 'GT1', y = 'Phenotype', color = 'GT2'))
  
} # plot_pxg_snps()


##########
# Given two SNPs, return the MAF at each one.
# Note that we use the 'B' allele in qtl2's SNP probs.
get_snp_maf = function(genoprobs, map, pos, query_func) {

  maf = rep(0, nrow(pos))

  for(i in 1:nrow(pos)) {
    si = query_func(pos$chr[i], pos$pos[i], pos$pos[i])
    si = subset(si, type == 'snp')
    si = qtl2:::index_snps(map, si)
    gt = genoprob_to_snpprob(genoprobs, si)[[1]][,'B',1]
    gt = round(2 * gt)
    
    maf[i] = min(table(gt) / length(gt))
  } # for(i)

  return(mutate(pos, maf = maf))

} # get_snp_maf()


# Get bulk SNP correlation for a region.
get_snp_cor = function(genoprobs, map, chr, start, end, query_func) {
  
  si = query_func(chr, start, end)
  si = subset(si, type == 'snp')
  si = qtl2:::index_snps(map, si)
  gt = genoprob_to_snpprob(genoprobs, si)[[1]][,'B',]
  gt = round(2 * gt)
  
  return(cor(gt))
  
} # get_snp_cor()


# Get bulk SNP correlation for SNPs in a snpinfo.
get_snp_cor = function(genoprobs, map, si) {
  
  #si = qtl2:::index_snps(map, si)
  gt = genoprob_to_snpprob(genoprobs, si)[[1]][,'B',]
  gt = round(2 * gt)
  
  return(cor(gt))
  
} # get_snp_cor()


# Get SNP correlation for two SNPs.
# snp_pos: data.frame containing chr, pos and SNP ID for both SNPs.
get_2snp_cor = function(genoprobs, map, snp_pos, query_func) {
  
  si = query_func(chr, snp_pos$pos[1], snp_pos$pos[1])
  si = subset(si, type == 'snp')
  si = qtl2:::index_snps(map, si)
  gt1 = 2 * round(genoprob_to_snpprob(genoprobs, si)[[1]][,'B',])
  
  si = query_func(chr, snp_pos$pos[2], snp_pos$pos[2])
  si = qtl2:::index_snps(map, si)
  gt2 = 2 * round(genoprob_to_snpprob(genoprobs, si)[[1]][,'B',])
  
  return(abs(cor(gt1, gt2)))
  
} # get_snp_cor()




# LD calculations (Uses 'genetics' package, which is out of maintenance.)
get_ld = function(probs, chr, start, end, query_func) {

  # Demo code that works.  
  a1 = matrix(sample(c('0/0', '0/1', '1/1'), 1000, replace = T, prob = c(0.25,0.5,0.25)), 100, 10)
  tmp = LD(makeGenotypes(a1))
  image(tmp$D)
  
  
} # get_ld()

